# PeiKeSmart Copilot 协作指令

本说明适用于沛柯智能（PeiKeSmart）及其全部开源 / 衍生项目。本指令用于规范在这些项目中使用 Copilot（及类似智能助手）时的行为，主要面向 Zig 0.15.2及以上 技术栈。

## 1. 目标
- 提效：减少机械样板劳动，聚焦业务/核心算法。
- 一致：风格、结构、命名、API 行为稳定。
- 可控：限制改动影响面、可审计、兼容友好、不引入隐患。
- 可靠：避免虚构、保持性能、不破坏现有合约。

## 2. 适用范围
- 含 PeiKeSmart 组件或其衍生的全部 Zig 仓库。
- 不含纯前端 / 非 Zig / 市场文案。
- 存在本文件 → 必须遵循；缺失可引入。

## 3. 角色与职责
- 开发者：提出清晰需求（功能/缺陷/性能/重构/文档）。
- Copilot：先检索再生成；输出必要且影响面受控的改动；不虚构；简体中文回复。
- 审核关键点：公共 API、一致性、性能影响。

## 4. 工作流
1) 需求分类 → 功能 / 修复 / 性能 / 重构 / 文档  
2) 检索 → 相关类型、目录、方法、已有扩展/工具  
3) 评估 → 是否公共 API / 是否性能热点  
4) 设计 → 列出改动点 + 兼容/降级策略  
5) 实施 → 局部编辑，限制改动影响面；保留原注释与结构  
6) 验证 → 通过编译；自动运行与本次改动相关的单元测试；若未发现任何相关测试，在结果中明确说明；不得自动新增测试项目  
7) 说明 → 变更摘要 / 影响范围  
8) 提交 → 统一格式，整理中文提交日志；禁止夹带无关格式化

## 5. 编码规范
- 忌全量重排、无差异格式化提交。
- 禁止擅自删除已有代码注释（含单行 // 与 XML 文档注释），可以修改或追加；禁止单独“清理”一片注释块或仅删除空白行来制造差异。
- 不得仅为对齐或所谓美观批量移除、合并空白行；保留有意的逻辑分隔空行。仅在同一局部有真实代码增删且需要保持统一时才可适度调整。

### 5.1 可读性优先（就近）
- 局部变量就近声明：在首次使用前的最近位置声明，避免集中在方法开头。
- 成组排布：相关成员按依赖顺序成组摆放，降低跳转成本。
- 合理例外：如会导致重复声明、闭包捕获或影响性能/生命周期，可权衡位置并加简短注释。

冲突时以“易读易懂”为先。

## 5.2 Zig 0.15.2+ 兼容性规范

- 必须使用 Zig 0.15.2 及以上版本标准库 API，禁止调用已废弃或重命名的旧 API。
- 常见变动：
	- `std.time.sleep` → 改为 `std.Thread.sleep`。
	- `std.mem.dupe` → 改为 `allocator.dupe`。
	- `std.mem.copy` 语法变更，需查阅新版文档。
	- `std.process.getEnvMap` 返回值类型变化，需用 `var` 而非 `const`。
	- 其他 API 变动请参考 Zig 官方 changelog。
- 编写新代码时，优先查阅 Zig 0.15.2+ 官方文档，避免参考旧版示例。
- 迁移/重构时，需逐一排查所有 API 用法，确保无旧接口残留。
- 如遇编译报错涉及 API 变动，优先查 changelog 或官方文档，禁止临时绕过。

### 5.2.1 ArrayList API 重大变更（Zig 0.15.2+）

**核心变更：** `std.ArrayList(T)` 返回的是 `Aligned(T, null)` 类型，该类型不再内部存储 allocator。

**禁止使用的旧 API：**
- ❌ `std.ArrayList(T).init(allocator)` — 此方法已移除
- ❌ `list.deinit()` — 缺少必需的 allocator 参数
- ❌ `list.append(item)` — 缺少必需的 allocator 参数

**正确用法：**

1. **初始化 ArrayList**
   ```zig
   // 方式 1: 使用空结构体字面量（推荐）
   var list: std.ArrayList(T) = .{};
   
   // 方式 2: 显式指定字段
   var list = std.ArrayList(T){ .items = &.{}, .capacity = 0 };
   
   // 方式 3: 使用预定义的空常量
   var list = std.ArrayList(T).empty;
   ```

2. **释放 ArrayList**
   ```zig
   // 必须传入 allocator
   defer list.deinit(allocator);
   ```

3. **添加元素**
   ```zig
   // 必须传入 allocator 作为第一个参数
   try list.append(allocator, item);
   ```

4. **其他常用操作**
   ```zig
   // 删除元素（不需要 allocator）
   _ = list.orderedRemove(index);
   const removed = list.swapRemove(index);
   
   // 访问元素（不变）
   const item = list.items[index];
   const len = list.items.len;
   
   // 清空但保留容量
   list.clearRetainingCapacity();
   
   // 清空并释放内存
   list.clearAndFree(allocator);
   ```

5. **结构体字段中的 ArrayList**
   ```zig
   pub const MyStruct = struct {
       allocator: Allocator,
       my_list: std.ArrayList(Item),
       
       pub fn init(allocator: Allocator) !MyStruct {
           return MyStruct{
               .allocator = allocator,
               .my_list = .{},  // 使用空字面量初始化
           };
       }
       
       pub fn deinit(self: *MyStruct) void {
           self.my_list.deinit(self.allocator);  // 传入 allocator
       }
       
       pub fn addItem(self: *MyStruct, item: Item) !void {
           try self.my_list.append(self.allocator, item);  // 传入 allocator
       }
   };
   ```

**迁移检查清单：**
- [ ] 所有 `ArrayList.init(allocator)` 改为 `.{}` 或等效形式
- [ ] 所有 `list.deinit()` 改为 `list.deinit(allocator)`
- [ ] 所有 `list.append(item)` 改为 `list.append(allocator, item)`
- [ ] 所有 `list.appendSlice(slice)` 改为 `list.appendSlice(allocator, slice)`
- [ ] 所有 `list.clearAndFree()` 改为 `list.clearAndFree(allocator)`
- [ ] 确认 `orderedRemove`、`swapRemove` 等不需要 allocator 的方法保持原样

**常见错误提示：**
- `error: struct 'array_list.Aligned(...)' has no member named 'init'` → 使用 `.{}` 初始化
- `error: member function expected N argument(s), found M` → 检查是否缺少或多传了 allocator 参数

## 6. 文档注释
- 示例可裁剪；避免泄露密钥、真实内部地址。

## 7. 异步与性能

### 7.1 异步编程原则
- **避免阻塞主线程**：网络请求、文件IO 等耗时操作应考虑异步处理或单独线程。
- **合理使用 `std.Thread`**：Zig 0.15.2+ 推荐使用 `std.Thread.spawn` 创建线程，`std.Thread.sleep` 替代旧版 `std.time.sleep`。
- **线程间通信**：优先使用 `std.Thread.Mutex`、`std.Thread.Condition` 等同步原语，避免数据竞争。

### 7.2 性能优化要点
- **内存分配管理**：合理选择 allocator，避免频繁小对象分配；使用 `defer` 确保资源释放。
- **编译优化**：生产环境使用 `ReleaseFast` 或 `ReleaseSmall` 模式；性能热点可考虑 `@inline` 提示。
- **避免不必要的拷贝**：优先传递切片（slice）而非完整数组；使用 `const` 引用减少复制开销。
- **循环优化**：减少循环内的分配和函数调用；考虑批量处理减少系统调用。

## 8. 日志与追踪

### 8.1 日志规范
- **统一日志接口**：使用 `std.log` 模块，支持不同级别（debug、info、warn、err）。
- **结构化输出**：重要操作记录关键参数，格式保持一致，便于后续分析。
- **敏感信息保护**：禁止记录密码、token 等敏感数据；如需调试可使用脱敏处理。

### 8.2 调试与追踪
- **错误上下文**：记录错误发生的文件、行号和相关参数，使用 `@src()` 获取源码位置。
- **性能监控**：关键路径可使用 `std.time.nanoTimestamp()` 测量耗时；避免在生产环境保留调试输出。
- **内存泄漏检测**：开发环境使用 `std.testing.allocator` 检测内存泄漏。

## 9. 错误处理

### 9.1 错误类型设计
- **明确错误集合**：定义具体的错误类型，避免使用通用 `error.GeneralFailure`。
- **错误传播**：使用 `!` 语法传播错误，在合适层级处理；避免忽略错误返回值。
- **错误恢复**：网络、文件操作等可恢复错误应提供重试机制；不可恢复错误及时终止。

### 9.2 错误处理模式
- **fail-fast 原则**：参数校验失败应立即返回错误，避免后续逻辑异常。
- **资源清理**：使用 `defer` 确保错误情况下的资源释放；复杂场景可考虑 RAII 模式。
- **错误日志**：记录错误详情但避免敏感信息泄露；为调试提供足够上下文。

### 9.3 Zig 0.15.2+ 错误处理实践
- **错误联合类型**：合理使用 `error union` 类型，明确函数可能返回的错误。
- **try 表达式**：使用 `try` 简化错误传播，使用 `catch` 进行错误恢复。
- **switch 错误处理**：对不同错误类型采用不同处理策略。

## 10. 测试

### 10.1 测试策略
- **单元测试**：每个公共函数应有对应测试，覆盖正常路径和边界条件。
- **集成测试**：验证模块间交互和接口兼容性。
- **回归测试**：修复 bug 后应添加对应测试防止重现。

### 10.2 Zig 0.15.2+ 测试实践
- **测试组织**：使用 `test` 块编写测试，文件内就近放置或单独 `tests/` 目录。
- **测试工具**：
  - `std.testing.expect` 进行断言检查
  - `std.testing.allocator` 检测内存泄漏
  - `std.testing.expectEqual` 精确值比较
- **测试运行**：使用 `zig build test` 执行全部测试；CI/CD 中应包含测试验证。

### 10.3 测试最佳实践
- **测试隔离**：每个测试独立，不依赖执行顺序；使用局部 allocator 避免测试间干扰。
- **模拟外部依赖**：网络请求、文件系统等外部依赖应提供 mock 实现。
- **性能测试**：关键算法可添加基准测试，监控性能回归。

### 10.3 多端调测
- 如果存在要多端同时调测的话，比如服务端和客户端需要同时运行来测试，那么先启动服务端，再启动客户端。
- 多端调测时要把服务端别起一个终端运行，避免运行新的命令时把服务端给关闭了。

## 11. Copilot 使用守则
- 仅回答开发相关；非开发 → “我是编程助手”。
- 输出前检索；禁止重复造轮子。
- 不生成超出需求的大块模板，先列方案再实现。
- 不新增外部依赖（除非说明内置不足并给出权衡）。
- 遇不确定上下文 → 标记“需查看文件”。
- 不伪造：测试结果 / 性能数据 / 外部调用。
- 回答或修改代码时，不得移除已有注释文本，可以修改或追加；不得单独删除整段注释或仅删除空白行制造“格式优化”式提交。
- 进行循环、控制流结构调整时，若原代码含循环花括号（即便单语句体），须保留，不得擅自移除。
- 修改或提交代码后，需自动在本地运行与改动相关的单元测试并确保通过；若无法定位相关测试，再运行最小必要集合或全部；若未找到任何测试，需在结果中明确说明且不自动新增测试项目。
- 生成文档：未特别指明时，默认以 Markdown（.md）格式输出，并使用 UTF-8 编码。
- 当出现新版本 Zig API 时，优先使用新 API，禁止调用已废弃或重命名的旧 API，且阅读和搜索最新源码来分析判断解决问题。

## 12. 变更与审核说明
提交或答复需包含：
- 概述：做了什么 / 为什么
- 影响：公共 API？性能？
- 兼容：降级策略 / 条件编译点
- 风险：潜在回归 / 性能开销
- 后续：是否补测试 / 文档

### 12.1 提交消息模板
```
类型(范围): 简短描述

详细说明变更内容和原因。

影响范围:
- [ ] 公共 API 变更
- [ ] 性能影响 (热点路径/内存分配)
- [ ] 兼容性变更 (Zig 版本/依赖)

测试情况:
- [ ] 单元测试已通过
- [ ] 集成测试已验证
- [ ] 性能回归测试 (如适用)

示例:
feat(module): 新增配置管理模块

实现基于环境变量和配置文件的参数管理功能。
支持多种数据源和运行时配置更新机制。

影响范围:
- [x] 公共 API 变更 (新增 Config 结构体和相关方法)
- [ ] 性能影响
- [ ] 兼容性变更

测试情况:
- [x] 单元测试已通过
- [x] 集成测试已验证
- [ ] 性能回归测试
```

## 13. 禁止清单
- 虚构 API / 文件 / 类型
- 未检索即重写或重复实现
- 擅自删除公共 / 受保护成员
- 引入重复第三方功能库
- 伪造测试/性能数据
- 在热点路径添加高分配 LINQ/反射（无缓存）
- 输出敏感凭据/内部地址
- 未审计第三方片段直接贴入
- 将非确定性行为直接断言（时间/随机）不隔离
- 强行异步化纯同步逻辑
- 大面积格式化无业务价值
- 擅自删除已有代码注释
- 仅删除或合并空白行以制造“变化”

## 14. 术语说明
- 热点路径：经性能分析或高频调用栈确认的关键执行段。
- 基线：变更前的功能/性能参考数据。

---
（完）